use std::str::FromStr;
use crate::ast::*;

grammar;

pub program_all: AST = {
    <l:@L> <p:procedures> <m:main> <r:@R> => AST::new( p, m, l, r ),
};

procedures: Vec<Procedure> = {
    <l:@L> <pr:procedures> "PROCEDURE" <ph:proc_head> "IS" <d:declarations> "IN" <c:commands> "END" <r:@R> => {
        let mut pr = pr;
        pr.push(Procedure::new( ph, d, c, l, r ));
        return pr;
    },
    <l:@L> <pr:procedures> "PROCEDURE" <ph:proc_head> "IS" "IN" <c:commands> "END" <r:@R> => {
        let mut pr = pr;
        pr.push(Procedure::new(ph, Vec::new(), c, l, r));
        return pr;
    },
    => {return Vec::new();},
};

main: Main = {
    <l:@L> "PROGRAM" "IS" <d:declarations> "IN" <c:commands> "END" <r:@R> => Main::new( d, c, l, r ),
    <l:@L> "PROGRAM" "IS" "IN" <c:commands> "END" <r:@R> => Main::new( Vec::new(), c, l, r ),
};

commands: Vec<Command> = {
    <c:commands> <cc:command> => {
        let mut c = c;
        c.push(cc);
        return c;
    },
    <c:command> => {return vec![c];},
};

command: Command = {
    <l:@L> <i:identifier> ":=" <e:expression> ";" <r:@R> => Command::Assign( Assign::new( i, e, l, r ) ),
    <l:@L> "IF" <c:condition> "THEN" <t:commands> "ELSE" <e:commands> "ENDIF"  <r:@R> => Command::If( If::new( c, t, e, l, r ) ),
    <l:@L> "IF" <c:condition> "THEN" <t:commands> "ENDIF"  <r:@R> => Command::If( If::new( c, t, Vec::new(), l, r ) ),
    <l:@L> "WHILE" <c:condition> "DO" <d:commands> "ENDWHILE"  <r:@R> => Command::While( While::new( c, d, l, r ) ),
    <l:@L> "REPEAT" <c:commands> "UNTIL" <u:condition> ";"  <r:@R> => Command::Repeat( Repeat::new( c, u, l, r ) ),
    <p:proc_call> ";" => Command::Call( p),
    <l:@L> "READ" <i:identifier> ";" <r:@R>  => Command::Read( Read::new( i, l, r ) ),
    <l:@L> "WRITE" <v:value> ";"  <r:@R> => Command::Write( Write::new( v, l, r ) ),
};

proc_head: ProcHead = {
    <l:@L> <name:r"[_a-z]+"> "(" <a:args_decl> ")" <r:@R> => ProcHead::new( name.to_owned(), a, l, r ),
};

proc_call: Call = {
    <l:@L> <name:r"[_a-z]+"> "(" <a:args> ")" <r:@R> => Call::new( name.to_owned(), a, l, r ),
};

declarations: Vec<Declaration> = {
    <l:@L> <d:declarations> "," <name:r"[_a-z]+"> <r:@R> => {
        let mut d = d;
        d.push(Declaration::new( name.to_owned(), DeclType::Number, l, r ) );
        return d;
    },
    <l:@L> <d:declarations> "," <name:r"[_a-z]+"> "[" <size:r"[0-9]+"> "]" <r:@R> => {
        let mut d = d;
        d.push(Declaration::new( name.to_owned(), DeclType::Table(u64::from_str(size).unwrap()), l, r ) );
        return d;
    },
    <l:@L> <name:r"[_a-z]+"> <r:@R> => {return vec![Declaration::new( name.to_owned(), DeclType::Number, l, r ) ];},
    <l:@L> <name:r"[_a-z]+"> "[" <size:r"[0-9]+"> "]" <r:@R> => {return vec![Declaration::new( name.to_owned(), DeclType::Table(u64::from_str(size).unwrap()), l, r ) ];},
};

args_decl: Vec<ArgDecl> = {
    <l:@L> <a:args_decl> "," <name:r"[_a-z]+"> <r:@R> => {
        let mut a = a;
        a.push(ArgDecl::new( name.to_owned(), ArgType::Number, l, r ) );
        return a;
    },
    <l:@L> <a:args_decl> "," "T" <name:r"[_a-z]+"> <r:@R> => {
        let mut a = a;
        a.push(ArgDecl::new( name.to_owned(), ArgType::Table, l, r ) );
        return a;
    },
    <l:@L> <name:r"[_a-z]+"> <r:@R> => {return vec![ArgDecl::new( name.to_owned(), ArgType::Number, l, r ) ];},
    <l:@L> "T" <name:r"[_a-z]+"> <r:@R> => {return vec![ArgDecl::new( name.to_owned(), ArgType::Table, l, r ) ];},
};

args: Vec<Arg> = {
    <l:@L> <a:args> "," <name:r"[_a-z]+"> <r:@R> => {
        let mut a = a;
        a.push(Arg::new( name.to_owned(), l, r ) );
        return a;
    },
    <l:@L> <name:r"[_a-z]+"> <r:@R> => {return vec![Arg::new( name.to_owned(), l, r ) ];},
};

expression: Expression = {
    <a:value> => Expression::Number( a ),
    <a:value> "+" <b:value> => Expression::Add( a, b ),
    <a:value> "-" <b:value> => Expression::Sub( a, b ),
    <a:value> "*" <b:value> => Expression::Mul( a, b ),
    <a:value> "/" <b:value> => Expression::Div( a, b ),
    <a:value> "%" <b:value> => Expression::Mod( a, b ),
};

condition: Condition = {
    <a:value> "=" <b:value> => Condition::Equal( a, b ),
    <a:value> "!=" <b:value> => Condition::NotEqual( a, b ),
    <a:value> "<" <b:value> => Condition::Less( a, b ),
    <a:value> ">" <b:value> => Condition::Greater( a, b ),
    <a:value> "<=" <b:value> => Condition::LessEqual( a, b ),
    <a:value> ">=" <b:value> => Condition::GreaterEqual( a, b ),
};

value: Value = {
    <name:r"[0-9]+"> => Value::Number( u64::from_str(name).unwrap() ),
    <i:identifier> => Value::Identifier( i ),
};

identifier: Identifier = {
    <l:@L> <name:r"[_a-z]+"> <r:@R> => Identifier::new(  name.to_owned(), IdentifierType::Number, l, r ),
    <l:@L> <name:r"[_a-z]+"> "[" <index:r"[0-9]+"> "]" <r:@R> => Identifier::new( name.to_owned(), IdentifierType::TableWithNumber(u64::from_str(index).unwrap()), l, r ),
    <l:@L> <name:r"[_a-z]+"> "[" <index:r"[_a-z]+"> "]" <r:@R> => Identifier::new( name.to_owned(), IdentifierType::TableWithIdentifier( index.to_owned() ), l, r ),
};

