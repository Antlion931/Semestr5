use std::str::FromStr;
use crate::ast::*;

grammar;

pub program_all: AST = {
    <p:procedures> <m:main> => AST::new( p, m ),
};

procedures: Vec<Procedure> = {
    <pr:procedures> "PROCEDURE" <ph:proc_head> "IS" <d:declarations> "IN" <c:commands> "END" => {
        let mut pr = pr;
        pr.push(Procedure::new( ph, d, c ));
        return pr;
    },
    <pr:procedures> "PROCEDURE" <ph:proc_head> "IS" "IN" <c:commands> "END" => {
        let mut pr = pr;
        pr.push(Procedure::new(ph, Vec::new(), c ));
        return pr;
    },
    => {return Vec::new();},
};

main: Main = {
    "PROGRAM" "IS" <d:declarations> "IN" <c:commands> "END" => Main::new( d, c ),
    "PROGRAM" "IS" "IN" <c:commands> "END" => Main::new( Vec::new(), c ),
};

commands: Vec<Command> = {
    <c:commands> <cc:command> => {
        let mut c = c;
        c.push(cc);
        return c;
    },
    <c:command> => {return vec![c];},
};

command: Command = {
    <i:identifier> ":=" <e:expression> ";" => Command::Assign( Assign::new( i, e ) ),
    "IF" <c:condition> "THEN" <t:commands> "ELSE" <e:commands> "ENDIF" => Command::If( If::new( c, t, e ) ),
    "IF" <c:condition> "THEN" <t:commands> "ENDIF" => Command::If( If::new( c, t, Vec::new() ) ),
    "WHILE" <c:condition> "DO" <d:commands> "ENDWHILE" => Command::While( While::new( c,  d ) ),
    "REPEAT" <c:commands> "UNTIL" <u:condition> ";" => Command::Repeat( Repeat::new( c, u ) ),
    <p:proc_call> ";" => Command::Call( p ),
    "READ" <i:identifier> ";" => Command::Read( Read::new( i ) ),
    "WRITE" <v:value> ";" => Command::Write( Write::new( v ) ),
};

proc_head: ProcHead = {
    <name:r"[_a-z]+"> "(" <a:args_decl> ")" => ProcHead::new( name.to_owned(), a ),
};

proc_call: Call = {
    <name:r"[_a-z]+"> "(" <a:args> ")" => Call::new( name.to_owned(), a ),
};

declarations: Vec<Declaration> = {
    <d:declarations> "," <name:r"[_a-z]+"> => {
        let mut d = d;
        d.push(Declaration::new( name.to_owned(), DeclType::Number ) );
        return d;
    },
    <d:declarations> "," <name:r"[_a-z]+"> "[" <size:r"[0-9]+"> "]" => {
        let mut d = d;
        d.push(Declaration::new( name.to_owned(), DeclType::Table(u64::from_str(size).unwrap()) ) );
        return d;
    },
    <name:r"[_a-z]+"> => {return vec![Declaration::new( name.to_owned(), DeclType::Number ) ];},
    <name:r"[_a-z]+"> "[" <size:r"[0-9]+"> "]" => {return vec![Declaration::new( name.to_owned(), DeclType::Table(u64::from_str(size).unwrap()) ) ];},
};

args_decl: Vec<ArgDecl> = {
    <a:args_decl> "," <name:r"[_a-z]+"> => {
        let mut a = a;
        a.push(ArgDecl::new( name.to_owned(), ArgType::Number ) );
        return a;
    },
    <a:args_decl> "," "T" <name:r"[_a-z]+"> => {
        let mut a = a;
        a.push(ArgDecl::new( name.to_owned(), ArgType::Table ) );
        return a;
    },
    <name:r"[_a-z]+"> => {return vec![ArgDecl::new( name.to_owned(), ArgType::Number ) ];},
    "T" <name:r"[_a-z]+"> => {return vec![ArgDecl::new( name.to_owned(), ArgType::Table ) ];},
};

args: Vec<Arg> = {
    <a:args> "," <name:r"[_a-z]+"> => {
        let mut a = a;
        a.push(Arg::new( name.to_owned() ) );
        return a;
    },
    <name:r"[_a-z]+"> => {return vec![Arg::new( name.to_owned() ) ];},
};

expression: Expression = {
    <a:value> => Expression::Number( a ),
    <a:value> "+" <b:value> => Expression::Add( a, b ),
    <a:value> "-" <b:value> => Expression::Sub( a, b ),
    <a:value> "*" <b:value> => Expression::Mul( a, b ),
    <a:value> "/" <b:value> => Expression::Div( a, b ),
    <a:value> "%" <b:value> => Expression::Mod( a, b ),
};

condition: Condition = {
    <a:value> "=" <b:value> => Condition::Equal( a, b ),
    <a:value> "!=" <b:value> => Condition::NotEqual( a, b ),
    <a:value> "<" <b:value> => Condition::Less( a, b ),
    <a:value> ">" <b:value> => Condition::Greater( a, b ),
    <a:value> "<=" <b:value> => Condition::LessEqual( a, b ),
    <a:value> ">=" <b:value> => Condition::GreaterEqual( a, b ),
};

value: Value = {
    r"[0-9]+" => Value::Number( u64::from_str(<>).unwrap() ),
    <i:identifier> => Value::Identifier( i ),
};

identifier: Identifier = {
    <name:r"[_a-z]+"> => Identifier::new(  name.to_owned(), IdentifierType::Number ),
    <name:r"[_a-z]+"> "[" <index:r"[0-9]+"> "]" => Identifier::new( name.to_owned(), IdentifierType::TableWithNumber(u64::from_str(index).unwrap()) ),
    <name:r"[_a-z]+"> "[" <index:r"[_a-z]+"> "]" => Identifier::new( name.to_owned(), IdentifierType::TableWithIdentifier( index.to_owned() ) ),
};

